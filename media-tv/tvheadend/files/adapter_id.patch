diff --git a/src/input/mpegts/linuxdvb/linuxdvb_adapter.c b/src/input/mpegts/linuxdvb/linuxdvb_adapter.c
index 91edf0772..10a9a4088 100644
--- a/src/input/mpegts/linuxdvb/linuxdvb_adapter.c
+++ b/src/input/mpegts/linuxdvb/linuxdvb_adapter.c
@@ -24,6 +24,9 @@
 #include "fsmonitor.h"
 #include "settings.h"
 
+#include "file.h"
+#include "spawn.h"
+
 #include <sys/types.h>
 #include <sys/ioctl.h>
 #include <sys/stat.h>
@@ -222,14 +225,55 @@ linuxdvb_adapter_new(const char *path, int a, const char *name,
   uint8_t uuidbin[20];
   char uhex[UUID_HEX_SIZE];
 
+  int outlen = -1, rd = -1;
+  char* args[4];
+  char cmd[1024];
+  char* outbuf;
+  char* _path;
+  char* _name;
+  size_t i;
+  
   /* Create hash for adapter */
   SHA1_Init(&sha1);
-  SHA1_Update(&sha1, (void*)path,     strlen(path));
-  SHA1_Update(&sha1, (void*)name,     strlen(name));
+  
+  /* Try to launch external program for adapter hash */
+  hts_settings_buildpath(cmd, sizeof(cmd), "adapter_id");
+  _path = strdup(path);
+  _name = strdup(name);
+  args[0] = cmd;
+  args[1] = _path;
+  args[2] = _name;
+  args[3] = NULL;
+  if (spawn_and_give_stdout(cmd, args, NULL, &rd, NULL, 1) >= 0)
+    outlen = file_readall(rd, &outbuf);
+  if (rd >= 0)
+    close(rd);
+  free(_path);
+  free(_name);
+  if (outlen > 0) {
+    i = 0;
+    while (i < outlen && outbuf[i] != '\n' && outbuf[i] != '\r' && outbuf[i] != '\0')
+      i++;
+    
+    SHA1_Update(&sha1, (void*)outbuf, i);
+    
+    outbuf[i] = 0;
+    tvhinfo(LS_LINUXDVB, "adapter id for %s is '%s'", path, outbuf);
+    
+    free(outbuf);
+  }
+  else {
+    /* Use hash from path and name */
+    SHA1_Update(&sha1, (void*)path,     strlen(path));
+    SHA1_Update(&sha1, (void*)name,     strlen(name));
+  }
+
   SHA1_Final(uuidbin, &sha1);
 
   bin2hex(uhex, sizeof(uhex), uuidbin, sizeof(uuidbin));
 
+  tvhinfo(LS_LINUXDVB, "adapter hash for %s is '%s'", path, uhex);
+
   /* Load config */
   *conf = hts_settings_load("input/linuxdvb/adapters/%s", uhex);
   if (*conf == NULL)
