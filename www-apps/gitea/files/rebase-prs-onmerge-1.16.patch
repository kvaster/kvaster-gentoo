diff --git a/routers/api/v1/repo/pull.go b/routers/api/v1/repo/pull.go
index 158abd465..d7bbabb5f 100644
--- a/routers/api/v1/repo/pull.go
+++ b/routers/api/v1/repo/pull.go
@@ -895,6 +895,13 @@ func MergePullRequest(ctx *context.APIContext) {
 			}
 			defer headRepo.Close()
 		}
+		if pr.BaseRepoID == pr.HeadRepoID {
+			if err := pull_service.RebaseBranchPulls(ctx, ctx.User, pr.HeadRepoID, pr.HeadBranch, pr.BaseBranch); err != nil {
+				log.Error("RebaseBranchPulls: %v", err)
+				ctx.Error(http.StatusInternalServerError, "RebaseBranchPulls", err)
+				return
+			}
+		}
 		if err := repo_service.DeleteBranch(ctx.User, pr.HeadRepo, headRepo, pr.HeadBranch); err != nil {
 			switch {
 			case git.IsErrBranchNotExist(err):
diff --git a/routers/web/repo/pull.go b/routers/web/repo/pull.go
index 6e68fd0c6..3260241ed 100644
--- a/routers/web/repo/pull.go
+++ b/routers/web/repo/pull.go
@@ -1328,6 +1328,15 @@ func CleanUpPullRequest(ctx *context.Context) {
 
 func deleteBranch(ctx *context.Context, pr *models.PullRequest, gitRepo *git.Repository) {
 	fullBranchName := pr.HeadRepo.Owner.Name + "/" + pr.HeadBranch
+
+	if pr.BaseRepoID == pr.HeadRepoID {
+		if err := pull_service.RebaseBranchPulls(ctx, ctx.User, pr.HeadRepoID, pr.HeadBranch, pr.BaseBranch); err != nil {
+			log.Error("RebaseBranchPulls: %v", err)
+			ctx.Flash.Error(ctx.Tr("repo.branch.deletion_failed", fullBranchName))
+			return
+		}
+	}
+
 	if err := repo_service.DeleteBranch(ctx.User, pr.HeadRepo, gitRepo, pr.HeadBranch); err != nil {
 		switch {
 		case git.IsErrBranchNotExist(err):
diff --git a/services/pull/pull.go b/services/pull/pull.go
index db3533ebe..33f53f4d2 100644
--- a/services/pull/pull.go
+++ b/services/pull/pull.go
@@ -495,6 +495,34 @@ func (errs errlist) Error() string {
 	return ""
 }
 
+// RebaseBranchPulls change target branch for all pull requests who's base branch is the branch
+func RebaseBranchPulls(ctx context.Context, doer *user_model.User, repoID int64, branch, targetBranch string) error {
+	prs, err := models.GetUnmergedPullRequestsByBaseInfo(repoID, branch)
+	if err != nil {
+		return err
+	}
+
+	if err := models.PullRequestList(prs).LoadAttributes(); err != nil {
+		return err
+	}
+
+	var errs errlist
+	for _, pr := range prs {
+		if err = pr.Issue.LoadAttributes(); err != nil {
+			errs = append(errs, err)
+		} else if err = ChangeTargetBranch(pr, doer, targetBranch); err != nil &&
+			!models.IsErrIssueIsClosed(err) && !models.IsErrPullRequestHasMerged(err) &&
+			!models.IsErrPullRequestAlreadyExists(err) {
+			errs = append(errs, err)
+		}
+	}
+
+	if len(errs) > 0 {
+		return errs
+	}
+	return nil
+}
+
 // CloseBranchPulls close all the pull requests who's head branch is the branch
 func CloseBranchPulls(doer *user_model.User, repoID int64, branch string) error {
 	prs, err := models.GetUnmergedPullRequestsByHeadInfo(repoID, branch)
