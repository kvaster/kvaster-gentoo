diff --git a/routers/api/v1/repo/pull.go b/routers/api/v1/repo/pull.go
index 50d2c9484..7a5c5f493 100644
--- a/routers/api/v1/repo/pull.go
+++ b/routers/api/v1/repo/pull.go
@@ -889,6 +889,13 @@ func MergePullRequest(ctx *context.APIContext) {
 			}
 			defer headRepo.Close()
 		}
+		if pr.BaseRepoID == pr.HeadRepoID {
+			if err := pull_service.RebaseBranchPulls(ctx, ctx.Doer, pr.HeadRepoID, pr.HeadBranch, pr.BaseBranch); err != nil {
+				log.Error("RebaseBranchPulls: %v", err)
+				ctx.Error(http.StatusInternalServerError, "RebaseBranchPulls", err)
+				return
+			}
+		}
 		if err := repo_service.DeleteBranch(ctx.Doer, pr.HeadRepo, headRepo, pr.HeadBranch); err != nil {
 			switch {
 			case git.IsErrBranchNotExist(err):
diff --git a/routers/web/repo/pull.go b/routers/web/repo/pull.go
index 6e8f575ad..d583def56 100644
--- a/routers/web/repo/pull.go
+++ b/routers/web/repo/pull.go
@@ -1359,6 +1359,15 @@ func CleanUpPullRequest(ctx *context.Context) {
 
 func deleteBranch(ctx *context.Context, pr *issues_model.PullRequest, gitRepo *git.Repository) {
 	fullBranchName := pr.HeadRepo.Owner.Name + "/" + pr.HeadBranch
+
+	if pr.BaseRepoID == pr.HeadRepoID {
+		if err := pull_service.RebaseBranchPulls(ctx, ctx.Doer, pr.HeadRepoID, pr.HeadBranch, pr.BaseBranch); err != nil {
+			log.Error("RebaseBranchPulls: %v", err)
+			ctx.Flash.Error(ctx.Tr("repo.branch.deletion_failed", fullBranchName))
+			return
+		}
+	}
+
 	if err := repo_service.DeleteBranch(ctx.Doer, pr.HeadRepo, gitRepo, pr.HeadBranch); err != nil {
 		switch {
 		case git.IsErrBranchNotExist(err):
diff --git a/services/pull/pull.go b/services/pull/pull.go
index 103fdc340..78b9a5c95 100644
--- a/services/pull/pull.go
+++ b/services/pull/pull.go
@@ -513,6 +513,34 @@ func (errs errlist) Error() string {
 	return ""
 }
 
+// RebaseBranchPulls change target branch for all pull requests who's base branch is the branch
+func RebaseBranchPulls(ctx context.Context, doer *user_model.User, repoID int64, branch, targetBranch string) error {
+	prs, err := issues_model.GetUnmergedPullRequestsByBaseInfo(repoID, branch)
+	if err != nil {
+		return err
+	}
+
+	if err := issues_model.PullRequestList(prs).LoadAttributes(); err != nil {
+		return err
+	}
+
+	var errs errlist
+	for _, pr := range prs {
+		if err = pr.Issue.LoadAttributes(ctx); err != nil {
+			errs = append(errs, err)
+		} else if err = ChangeTargetBranch(ctx, pr, doer, targetBranch); err != nil &&
+			!issues_model.IsErrIssueIsClosed(err) && !models.IsErrPullRequestHasMerged(err) &&
+			!issues_model.IsErrPullRequestAlreadyExists(err) {
+			errs = append(errs, err)
+		}
+	}
+
+	if len(errs) > 0 {
+		return errs
+	}
+	return nil
+}
+
 // CloseBranchPulls close all the pull requests who's head branch is the branch
 func CloseBranchPulls(doer *user_model.User, repoID int64, branch string) error {
 	prs, err := issues_model.GetUnmergedPullRequestsByHeadInfo(repoID, branch)
